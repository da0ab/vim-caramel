set nocompatible
set encoding=utf-8
set fileencodings=utf-8,koi8-r,cp1251,cp866
filetype plugin indent on
set helplang=ru
set guioptions-=T
set clipboard=unnamed
let mapleader = "."
set timeoutlen=800

if version >= 700
    set history=64
    set undodir=~/.vim/tmp/
    set undofile
    set undolevels=1000
    set undoreload=10000
endif
set noswapfile

nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
inoremap <Down> <C-o>gj
inoremap <Up> <C-o>gk
set cursorline
set ruler
autocmd InsertLeave,WinEnter * set cursorline
autocmd InsertEnter,WinLeave * set nocursorline
set mousemodel=popup
set mouse=a
set mousehide

set fileencoding=utf-8
set fileencodings=utf-8,cp1251,koi8-r
set iskeyword+=192-255,:,;,(,),-
set complete=.,k
set completeopt=menuone,noinsert,noselect
set shortmess+=c
set wildmenu
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : (col('.') > 1 && getline('.')[col('.') - 2]  =~ '\k') ? "\<C-n>" : "\<Tab>"
autocmd FileType css,html setlocal dictionary+=~/.vim/dict/css.dict

syntax on
set wrap
set linebreak
set nu
set smartindent
set tabstop=4
set shiftwidth=1
set softtabstop=4
set expandtab
set autoindent
set nofoldenable
set foldmethod=manual
set showmatch
imap [ []<LEFT>
imap ( ()<LEFT>
imap { {<CR>}<C-O>O
function InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
imap <tab> <c-r>=InsertTabWrapper()<cr>
autocmd BufWritePre * silent! %s/[\r \t]\+$//

let g:angle_chars = {
      \ 'left': '',
      \ 'right': '',
      \ 'left_thin': '',
      \ 'right_thin': ''
      \}
autocmd VimEnter * highlight! Space_0 guifg=#000000 guibg=#0b0b14
autocmd VimEnter * highlight! Text_0 guifg=#cd5c54 guibg=#0b0b14 gui=bold
autocmd VimEnter * highlight! Angle_0 guifg=#000000 guibg=#161623
autocmd VimEnter * highlight! Space_1 guifg=#222222 guibg=#161623
autocmd VimEnter * highlight! Text_1 guifg=#FFFFFF guibg=#161623 gui=bold
autocmd VimEnter * highlight! Angle_1 guifg=#222222 guibg=#444444
autocmd VimEnter * highlight! Space_2 guifg=#444444 guibg=#444444
autocmd VimEnter * highlight! Text_2 guifg=#FFFFFF guibg=#444444 gui=bold
autocmd VimEnter * highlight! Angle_2 guifg=#444444 guibg=#666666
autocmd VimEnter * highlight! Angle_5 guifg=#222222 guibg=#666666
set showmode
set wildmenu
set laststatus=2
set statusline=
set statusline+=%#Space_0#\
set statusline+=%h%#Text_0#%{&modified?'СОХРАНИ':''}%*%r
set statusline+=%#Space_0#\
set statusline+=%#Angle_0#%{g:angle_chars.right}
set statusline+=%#Text_1#\ Строки\ %L\ ∙\ \%l\ ∙\ \%p%%
set statusline+=%#Space_1#\
set statusline+=%#Angle_1#%{g:angle_chars.right}
set statusline+=%#Text_2#\ Символы\ %{CharCount()}\ ∙\ \%{virtcol('$')-1}\ ∙\ \%v
set statusline+=%#Space_2#\
set statusline+=%#Angle_2#%{g:angle_chars.right}
function! CharCount()
    if !exists("b:charcount")
        let b:charcount = join(getline(1, '$'), '')->strlen()
    endif
    return '' . b:charcount
endfunction
autocmd BufWritePost,TextChanged,TextChangedI * unlet! b:charcount
set statusline+=%=
set statusline+=%#Angle_5#%{g:angle_chars.left}
set statusline+=%#Space_1#\
set statusline+=%#Text_1#\ \%{&fileencoding}
set statusline+=%#Space_1#\

set hlsearch
set ignorecase
set incsearch
set smartcase
set nowrapscan
set infercase
set hlsearch
nohlsearch

set shm+=I
colorscheme dark_puerh
set guifont=AnonymicePro\ Nerd\ Font\ Propo:h14
set lines=75
set columns=210
set ch=1
set cursorline
set termguicolors
set foldcolumn=1
set fillchars+=eob:.

map ё `
map й q
map ц w
map у e
map к r
map е t
map н y
map г u
map ш i
map щ o
map з p
map х [
map ъ ]
map ф a
map ы s
map в d
map а f
map п g
map р h
map о j
map л k
map д l
map ж ;
map э '
map я z
map ч x
map с c
map м v
map и b
map т n
map ь m
map б ,
map ю .
map . /
map Ё ~
map Й Q
map Ц W
map У E
map К R
map Е T
map Н Y
map Г U
map Ш I
map Щ O
map З P
map Х {
map Ъ }
map Ф A
map Ы S
map В D
map А F
map П G
map Р H
map О J
map Л K
map Д L
map Ж :
map Э "
map Я Z
map Ч X
map С C
map М V
map И B
map Т N
map Ь M
map Б <
map Ю >
map , ?

map <C-Q> <Esc>:q!<cr>
nnoremap <Space> <PageDown>
nnoremap <S-Space> <PageUp>
nnoremap m. :tabnext<CR>
nnoremap m, :tabprevious<CR>
for i in range(1, 9)
  execute "nnoremap m" . i . " " . i . "gt"
endfor
vmap < <gv
vmap > >gv
vmap <C-C> "+y
imap <C-V> <esc>"+gp
vnoremap <C-v> "_d"+p
nnoremap <C-a> ggVG
inoremap <C-a> <Esc>ggVG
vnoremap <C-a> <Esc>ggVG
nnoremap <C-d> :copy.<CR>
inoremap <C-d> <Esc>:copy.<CR>gi
vnoremap <C-d> y`>pgv`<
nnoremap <C-x> dd
inoremap <C-x> <Esc>ddi
vnoremap <C-x> d
nnoremap <F1> :w!<CR>
inoremap <F1> <Esc>:w!<CR>
vnoremap <F1> <Esc>:w!<CR>
augroup auto_source_vimrc
  autocmd!
  autocmd BufWritePost $MYVIMRC source $MYVIMRC | echo "✅ .vimrc reloaded"
augroup END
nmap <F2> ^vg_
nnoremap <F3> vit
inoremap <F3> <C-O>vit
nnoremap <F4> vat
inoremap <F4> <C-O>vat
nmap <F6> :g/^s*$/d
nnoremap <S-F6> :%s/\v\n(\s*\n)+/\r\r/<CR>:noh<CR>
set wildmenu
set wcm=<Tab>
menu Encoding.windows-1251 :e ++enc=cp1251 ++ff=dos<CR>
menu Encoding.utf-8 :e ++enc=utf8<CR>
menu Encoding.cp866 :e ++enc=cp866 ++ff=dos<CR>
menu Encoding.koi8-r :e ++enc=koi8-r ++ff=unix<CR>
menu Encoding.koi8-u :e ++enc=koi8-u ++ff=unix<CR>
map <F8> :emenu Encoding.<TAB>
    function MyToggleMenu()
        let old_guioptions = &guioptions
        if stridx(old_guioptions, 'm') != -1
            set guioptions-=m
        else
            set guioptions+=m
        endif
    endfunction
    cmap <F9> <ESC>:call MyToggleMenu()<CR>
    imap <F9> <ESC>:call MyToggleMenu()<CR>
    nmap <F9> :call MyToggleMenu()<CR>
    vmap <F9> <ESC>:call MyToggleMenu()<CR>
function! WrapWithTag(type) abort
  let l:raw_input = input('Tag (> для построчной обёртки): ')
  if empty(l:raw_input)
    return
  endif
  let l:raw_input = substitute(l:raw_input, '^>\(\S\)', '> \1', '')
  let l:parts = split(l:raw_input)
  let l:is_line_wrap = (get(l:parts, 0, '') ==# '>')
  let l:tag = l:is_line_wrap ? get(l:parts, 1, '') : get(l:parts, 0, '')
  let l:class = l:is_line_wrap ? get(l:parts, 2, '') : get(l:parts, 1, '')
  if empty(l:tag)
    echo '❌ Не указан тег'
    return
  endif
  let l:class_str = l:class !=# '' ? ' class="'.l:class.'"' : ''
  let l:open_tag = '<'.l:tag.l:class_str.'>'
  let l:close_tag = '</'.l:tag.'>'
  if a:type ==# 'v'
    let [line1, col1] = getpos("'<")[1:2]
    let [line2, col2] = getpos("'>")[1:2]
    if line1 != line2
      let l:lines = getline(line1, line2)
      let l:lines[0] = l:lines[0][col1-1 :]
      let l:lines[-1] = l:lines[-1][: col2-1]
      let l:wrapped = [l:open_tag] + l:lines + [l:close_tag]
      call setline(line1, l:wrapped)
      if line2 > line1 + len(l:wrapped) - 1
        execute (line1 + len(l:wrapped)) . ',' . line2 . 'delete _'
      endif
      return
    endif
    let l:line = getline(line1)
    if col2 < col1
      let [col1, col2] = [col2, col1]
    endif
    let l:start = col1 - 1
    let l:end = col2 - 1
    while l:start > 0 && l:line[l:start] =~ '[\x80-\xBF]'
      let l:start -= 1
    endwhile
    while l:end < strlen(l:line) - 1 && l:line[l:end + 1] =~ '[\x80-\xBF]'
      let l:end += 1
    endwhile
    let l:has_trailing_space = 0
    if l:end < strlen(l:line) - 1 && l:line[l:end + 1] ==# ' '
      let l:has_trailing_space = 1
    endif
    if l:line[l:end] ==# ' '
      let l:end -= 1
      let l:has_trailing_space = 1
    endif
    let l:newline = strpart(l:line, 0, l:start) .
          \ l:open_tag .
          \ strpart(l:line, l:start, l:end - l:start + 1) .
          \ l:close_tag .
          \ (l:has_trailing_space ? ' ' : '') .
          \ strpart(l:line, l:end + 1 + (l:has_trailing_space ? 1 : 0))
    call setline(line1, l:newline)
  elseif a:type ==# 'V'
    let l:start = line("'<")
    let l:end = line("'>")
    if l:is_line_wrap
      for lnum in range(l:start, l:end)
        let l:line = getline(lnum)
        if l:line =~ '^\s*$'
          continue
        endif
        call setline(lnum, l:open_tag . l:line . l:close_tag)
      endfor
    else
      let l:lines = getline(l:start, l:end)
      let l:wrapped = [l:open_tag] + l:lines + [l:close_tag]
      call setline(l:start, l:wrapped)
      if l:end > l:start + len(l:wrapped) - 1
        execute (l:start + len(l:wrapped)) . ',' . l:end . 'delete _'
      endif
    endif
  else
    let l:line = getline('.')
    call setline('.', l:open_tag . l:line . l:close_tag)
  endif
endfunction
nnoremap <silent> <F10> :call WrapWithTag('n')<CR>
vnoremap <silent> <F10> :<C-u>call WrapWithTag(visualmode())<CR>
inoremap <silent> <F10> <Esc>:call WrapWithTag('n')<CR>
set wildmenu
set wildmode=longest,list,full
let g:insert_snippets = {
  \ 'texterea':           '<textarea rows="3" placeholder=""></textarea>',
  \ 'input':              '<input type="text" placeholder="">',
  \ 'radio':              '<input type="radio">',
  \ 'checkbox':           '<input type="checkbox">',
  \ 'media phone':        "/*phone*/\n@media (max-width: 769px) {\n\t\n}",
  \ 'media pad':          "/*pad*/\n@media (min-width: 769px) and (max-width: 1024px) {\n\t\n}",
  \ 'media pad portrait': "/*pad portrait*/\n@media  (min-width : 768px) and (max-width: 1024px) and (orientation: portrait) {\n\t\n}",
  \ 'media notebook':     "/*notebook*/\n@media only screen and (max-width: 1650px) {\n\t\n}",
  \ 'media square':       "/*square*/\n@media screen and (min-width: 1025px) and (max-width: 1400px) {\n\t\n}",
  \ 'text-shadow':        'text-shadow: 0 0 10px #d1d1d1',
  \ 'colspan':            'colspan="2"',
  \ 'rowspan':            'rowspan="2"',
  \ 'copy':               '©',
  \ 'seo':            "<meta name=\"description\" content=\"\">\n<meta name=\"keywords\" content=\"\">\n<meta name=\"author\" content=\"\">\n<meta name=\"copyright\" lang=\"ru\" content=\"\">\n<meta name=\"robots\" content=\"all\">",
  \ 'html5':          "<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n\t<meta charset=\"utf-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t<meta name=\"format-detection\" content=\"telephone=no\">\n\t<link rel=\"stylesheet\" href=\"css/ProTo.min.css?v=0.0.1\">\n\t<title></title>\n</head>\n<body>\n\n\t<script type=\"text/javascript\" src=\"js/vendor.min.js?v=0.0.1\"></script>\n\t<script type=\"text/javascript\" src=\"js/ProTo.min.js?v=0.0.1\"></script>\n</body>\n</html>",
  \ 'html mini':       "<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n\t<meta charset=\"utf-8\">\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1.0, user-scalable=no\">\n\t<title></title>\n</head>\n<body>\n\n</body>\n</html>",
  \ 'webkit':             '-webkit-',
  \ 'version':            '?v=0.0.1',
  \ 'cover':              'background-size: cover'
\ }
function! SnippetComplete(A, L, P)
  let matches = []
  for key in keys(g:insert_snippets)
    if key =~ '^' . a:A
      call add(matches, key)
    endif
  endfor
  return matches
endfunction
function! InsertSnippet()
  let key = input('Вставка по ключу: ', '', 'customlist,SnippetComplete')
  if has_key(g:insert_snippets, key)
    execute "normal! a" . g:insert_snippets[key]
    if key == 'pad'
      execute "normal! k$"
    endif
  else
    echo "Нет соответствующего сниппета для ключа: " . key
  endif
endfunction
nnoremap <F11> :call InsertSnippet()<CR>
inoremap <F11> <Esc>:call InsertSnippet()<CR>
nnoremap <F12> :NERDTreeToggle<CR>
inoremap <F12> <C-O>:NERDTreeToggle<CR>
nnoremap <leader>l :echo "t - дата, v - vimrc, h - хелпик "<CR>
imap <leader>t <C-R>= '-----/ ' . toupper(strftime("%d %B %Y • %H:%M:%S %A")) . ' /-----'<CR>
nnoremap <leader>v :vsp $MYVIMRC<CR> Редактировать .vimrc
nnoremap <leader>v :vsp $MYVIMRC<CR>
nnoremap <leader>h :e <C-R>=expand("~/.vim/my-help.vim")<CR><CR>

vnoremap pp 1"zdi<p><C-R>z</p><ESC>
vnoremap bb "zdi<strong><C-R>z</strong><ESC>
vnoremap sb "zdi<b><C-R>z</b><ESC>
vnoremap ii "zdi<em><C-R>z</em><ESC>
vnoremap si "zdi<i><C-R>z</i><ESC>
vnoremap sq "zdi«<C-R>z»<ESC>
vnoremap s1 "zdi<h1><C-R>z</h1><ESC>
vnoremap s2 "zdi<h2><C-R>z</h2><ESC>
vnoremap s2t "zdi<h2 class="title"><C-R>z</h2><ESC>
vnoremap s3 "zdi<h3><C-R>z</h3><ESC>
vnoremap s4 "zdi<h4><C-R>z</h4><ESC>
vnoremap s5 "zdi<h5><C-R>z</h5><ESC>
vnoremap s6 "zdi<h6><C-R>z</h6><ESC>"
vnoremap sa "zdi<a href="<esc>maa"><C-R>z</a><ESC>`aa
vnoremap saa "zdi<a href="<C-R>z"><C-R>z</a><ESC>`aa
vnoremap sat "zdi<a href="<esc>maa" target="_blank" rel="nofollow"><C-R>z</a><ESC>`aa
vnoremap saat "zdi<a href="https://<C-R>z" target="_blank" rel="nofollow"><C-R>z</a><ESC>`aa
vnoremap s@ "zdi<a href="mailto:<C-R>z"><C-R>z</a><Esc>
vnoremap st "zdi<a href="tel:<C-R>z"><C-R>z</a><ESC>
vnoremap sd 1"zdi<div><cr><C-R>z<cr><C-R> </div><ESC>
vnoremap sdi 1"zdi<div id=""><C-R>z</div><ESC>
vnoremap sdc 1"zdi<div class=""><cr><C-R>z<cr><C-R> </div><ESC>
vnoremap spa "zdi<span class=""><C-R>z</span><ESC>
vnoremap span "zdi<span><C-R>z</span><ESC>
vnoremap sec 1"zdi<section><cr><C-R>z<cr></section><ESC>
vnoremap secc 1"zdi<section class="main"><cr><C-R>z<cr></section><ESC>
vnoremap details 1"zdi<details><cr><summary><C-R>z</summary><cr><cr></details><ESC>
vnoremap det 1"zdi<details><cr><summary><C-R>z</summary><cr><cr></details><ESC>
vnoremap sl 1"zdi<li><C-R>z</li><ESC>
vnoremap sw "zdi<img src="images/<C-R>z" alt="" title=""><ESC>
vnoremap swl "zdi<a href="images/<C-R>z" class="iPop-img"><img src="images/<C-R>z" alt="" title=""></a><ESC>
vnoremap swv "zdi<a href="<C-R>z"class="iPop-video"></a><ESC>
vnoremap ss 1"zdi<!--<C-R>z --><ESC>
vnoremap sc 1"zdi/*<C-R>z*/<ESC>
vnoremap sx 1"zdi/*-------------------- <C-R>z --------------------*/<ESC>
vnoremap sv 1"zdi" ===== <C-R>z =====<ESC>
inoremap <C-Enter> <br>
inoremap \a <a id="" class="anchor"></a>
inoremap \<Space> &nbsp;
inoremap \i <C-Space>id=""
inoremap \c <C-Space>class=""
inoremap \w width:;
inoremap \h height:;
inoremap \l <cr><hr><cr>
inoremap \-  –
inoremap \v var(--);
inoremap \ff color: #fff;
inoremap \b border: 1px solid #ddd;
inoremap \1  <C-Space>!important
inoremap \fw font-weight: bold;
inoremap \bg background: transparent url(../images/) no-repeat center;
inoremap \sh #!/bin/bash
inoremap \py #!/usr/bin/env python3<cr># -*- coding: utf-8 -*-
inoremap \s <style type="text/css"><cr><cr></style>
inoremap \j <script type="text/javascript" src="js"><cr><cr></script>
inoremap \css <link rel="stylesheet" href="css/ProTo.min.css?v=0.0.1">

vnoremap <silent> sp :%!python3 ~/.vim/scripts/p.py<CR>
vnoremap <silent> sdd :%!python3 ~/.vim/scripts/div.py<CR>
vnoremap <silent> su :%!python3 ~/.vim/scripts/li.py<CR>
imap <F7> <C-R>:%!python3 ~/.vim/scripts/clean_html.py<CR>
nmap <F7> :%!python3 ~/.vim/scripts/clean_html.py<CR>
vmap <F7> <Esc>:%!python3 ~/.vim/scripts/clean_html.py<CR>

execute pathogen#infect()
syntax on

let g:webdevicons_enable = 1
let g:webdevicons_enable_nerdtree = 1
let g:NERDTreeShowIcons = 1
function! NERDTreeRenderNodeCustom(item)
  let icon = WebDevIconsGetNerdTreeFileNodeSymbol(a:item)
  let name = a:item.name
  return icon . name
endfunction
let g:WebDevIconsNerdTreeBeforeGlyphPadding = ''
let g:WebDevIconsNerdTreeAfterGlyphPadding = ''
let g:WebDevIconsUnicodeDecorateFolderNodes = 1
let g:WebDevIconsUnicodeDecorateFileNodes = 1
let g:WebDevIconsNerdTreeCustomRender = 1
let g:nerdtree_auto_opened = 0
let g:NERDTreeLimitedSyntax = 0
let g:NERDTreeSyntaxEnabled = 1
nnoremap <C-f> :NERDTreeFind<CR>
let NERDTreeShowHidden=1
autocmd BufWritePost * if &ft == 'nerdtree' | silent NERDTreeSyntaxRefresh | endif
let g:NERDTreeSyntaxDisableDefaultExtensions = 0
let g:NERDTreeSyntaxEnabledExtensions = ['js', 'py', 'vim', 'md', 'txt']
highlight NERDTreeFileExtension_js  guifg=#F0DB4F ctermfg=220
highlight NERDTreeFileExtension_py  guifg=#3572A5 ctermfg=67
highlight NERDTreeFileExtension_vim guifg=#199F4B ctermfg=35
highlight NERDTreeFileExtension_md  guifg=#FF79C6 ctermfg=212
highlight nerdtreeFileExtensionLabel_js    guifg=#E5C07B
highlight nerdtreeFileExtensionLabel_html  guifg=#E06C75
highlight nerdtreeFileExtensionLabel_vim   guifg=#98C379
highlight nerdtreeFileExtensionLabel_md    guifg=#FFFFFF
highlight nerdtreeFileExtensionLabel_json  guifg=#E5C07B
if has('gui_running')
  hi StatusLine   guifg=#ffffff guibg=#0b0b14 gui=NONE
  hi StatusLineNC guifg=#808080 guibg=#0b0b14 gui=NONE
endif

function! FixSignatureColors()
    hi SignatureMarkText  guifg=#6c6c6c guibg=#1e1e2e ctermfg=242 ctermbg=236 gui=NONE cterm=NONE
    hi SignatureMarkerText guifg=#5c5c5c guibg=#1e1e2e ctermfg=240 ctermbg=236 gui=NONE cterm=NONE
endfunction
autocmd VimEnter,ColorScheme * call FixSignatureColors()

let g:startify_change_to_vcs_root = 1
let g:startify_enable_special = 1
let g:startify_use_devicons = 1
function! GetWelcomeMessage()
  let l:file = expand("~/.vim/help/start-help.vim")
  if filereadable(l:file)
    let l:lines = readfile(l:file)
    if !empty(l:lines)
      let quote = l:lines[rand() % len(l:lines)]
      let len_quote = len(quote) + 6
      let top = '┌' . repeat('─', len_quote) . '┐'
      let middle = '   ' . quote . '   '
      let bottom = '└' . repeat('─', len_quote) . '┘'
      return [
            \ '',
            \ top,
            \ middle,
            \ bottom,
            \ ''
            \ ]
    endif
  endif
  return ['   (Цитата не найдена)']
endfunction
autocmd FileType startify syntax match StartifyHotkey /"\s\zs\(\S\{2,4}\):/ containedin=StartifyHeader
highlight StartifyHotkey guifg=#fabd2f ctermfg=214 gui=bold
let g:startify_custom_header = GetWelcomeMessage()
let g:startify_lists = [
      \ { 'type': 'files', 'header': ['   A few moments earlier...'] },
      \ { 'type': 'bookmarks', 'header': ['   Bookmarks'] }
      \ ]
let g:startify_bookmarks = [
      \ { 'p': '~/prompts.txt' },
      \ { 'b': '~/.bash_profile' },
      \ { 'h': '~/.vim/help/my-help.vim' },
      \ { 's': '~/.vim/start-help.vim' },
      \ { 'v': '~/Dropbox/worck/GIT/vim-caramel' },
      \ { '.v': '~/.vimrc' },
      \ { 'c': '~/Dropbox/worck/GIT/vim-caramel/dict/css.dict' }
      \ ]
augroup StartifySyntax
  autocmd!
  autocmd FileType startify syntax match StartifyBracketLeft /\[/ contained
  autocmd FileType startify syntax match StartifyBracketRight /\]/ contained
  autocmd FileType startify :
    \ syntax match StartifyFile /\[[^\]]\+\]/ containedin=StartifySection |
    \ syntax match StartifyPath /\/[^\/]*$/ containedin=StartifyFile
  autocmd FileType startify :
    \ syntax match StartifyExt /\.\w\+\($\|\[\)/ containedin=StartifyFile |
    \ syntax match StartifyExt /\/\.[^\/]\+\// containedin=StartifyPath
augroup END
highlight StartifyExt   guifg=#83a598 ctermfg=109  " Общий цвет расширений (голубой)
highlight StartifyExtVim guifg=#b16286 ctermfg=132  " .vim (фиолетовый)
highlight StartifyExtPy  guifg=#458588 ctermfg=66   " .py (синий)
highlight StartifyExtJs  guifg=#d79921 ctermfg=172  " .js (оранжевый)
highlight StartifyExtMd  guifg=#8ec07c ctermfg=108  " .md (зелёный)
highlight StartifyBracketLeft  guifg=#444444 ctermfg=240
highlight StartifyBracketRight guifg=#444444 ctermfg=240
autocmd FileType startify :
  \ syntax match StartifyExtVim /\.vim\($\|\[\)/ containedin=StartifyFile |
  \ syntax match StartifyExtPy  /\.py\($\|\[\)/ containedin=StartifyFile |
  \ syntax match StartifyExtJs  /\.js\($\|\[\)/ containedin=StartifyFile |
  \ syntax match StartifyExtMd  /\.md\($\|\[\)/ containedin=StartifyFile

